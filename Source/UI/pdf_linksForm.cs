//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#undef USE_PRIVATE
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using iTextSharp.text;
using iTextSharp.text.pdf;
using PP = iTextSharp.text.pdf.parser;
using ITF = iTextSharp.text.Font;
using System.Collections;

namespace NSPdf_links {
    public partial class pdf_linksForm : INotifyPropertyChanged {

        #region constants
        const string DRAG_TYPE = "FileDrop";
        #endregion

        #region fields
#if USE_PRIVATE
        PropertyChangedEventHandler _pceh;
        event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged { add { _pceh += value; } remove { _pceh -= value; } }
#else
        public event PropertyChangedEventHandler PropertyChanged;
#endif
        static string _findFile;
        List<FullFilePath> _instrSheets = new List<FullFilePath>();
        List<FullFilePath> _opSheets = new List<FullFilePath>();
        string _insSheetLoc;
        string _opSheetLoc;
        string prev;
        string _findModel;
        #endregion

        #region ctor
        public pdf_linksForm() {
            InitializeComponent();

            this.DataBindings.Add("instructionSheetLocation", this.tbInstSheet, "Text");
            this.DataBindings.Add("opsheetLocation", this.tbOpSheet, "Text");

            this.tbInstSheet.DataBindings.Add("Text", this, "instructionSheetLocation");
            this.tbOpSheet.DataBindings.Add("Text", this, "opsheetLocation");


        }
        #endregion

        #region properties
        public string instructionSheetLocation {
            get { return _insSheetLoc; }
            set {
                if (string.Compare(this.instructionSheetLocation, value, true) != 0) {
                    _insSheetLoc = value;
                    doNotify(MethodBase.GetCurrentMethod());
                }
            }
        }

        public string opsheetLocation {
            get { return _opSheetLoc; }
            set {
                if (string.Compare(this.opsheetLocation, value, true) != 0) {
                    _opSheetLoc = value;
                    doNotify(MethodBase.GetCurrentMethod());
                }
            }
        }

        #endregion

        #region action methods
        void exitClick(object sender, EventArgs ea) {
            CancelEventArgs cea = new CancelEventArgs();

            Application.Exit(cea);
            if (cea.Cancel) {
                return;
            }
            Application.Exit();
        }

        void formLoad(object sender, EventArgs ea) {
            instructionSheetLocation = @"U:\Pack\Instruction_Sheets\Approved";
            opsheetLocation = @"U:\Pack\OpSheets\Approved";
        }

        void tsmiFileNew_Click(object sender, EventArgs e) {
            createDocument("new_test.pdf");

        }

        void btnCreate_Click(object sender, EventArgs e) {
            SaveFileDialog ofd = new SaveFileDialog();
            string dir;

            ofd.InitialDirectory = Directory.GetCurrentDirectory();
            ofd.Filter = "PDF|*.pdf";
            ofd.FilterIndex = 0;
            ofd.AddExtension = true;
            if (!string.IsNullOrEmpty(prev)) {
                ofd.InitialDirectory = dir = Path.GetDirectoryName(prev);
                ofd.FileName = Path.GetFileName(prev);
            }
            if (ofd.ShowDialog() == DialogResult.OK) {
                createDocument(prev = ofd.FileName);
            }
        }
        void btnClear_Click(object sender, EventArgs e) {
            resetDataSource(lbInstruct, _instrSheets);
            resetDataSource(lbOps, _opSheets);
        }
        #endregion

        void btnGenOpSheet_Click(object sender, EventArgs e) {
            IDictionary<string, List<FullFilePath>> modelMap;
            FullFilePath ffp;
            string[] files;
            string model, wildCard;
            const string DEFAULT_WILDCARD = "*.pdf";

            wildCard = DEFAULT_WILDCARD;
            //wildCard = "R0920*.pdf";
            //wildCard = "R092*.pdf";
            files = Directory.GetFiles(this.opsheetLocation, wildCard);
            if (files.Length > 0) {
                modelMap = new Dictionary<string, List<FullFilePath>>();
                foreach (string afile in files) {
                    ffp = new FullFilePath(afile, true);
                    if (ffp.isValid) {
                        _findModel = model = ffp.model;
                        _findModel = afile;
                        if (!modelMap.ContainsKey(model))
                            modelMap.Add(model, new List<FullFilePath>());
                        if (!modelMap[model].Exists(findByRealPath))
                            modelMap[model].Add(ffp);
                    }
                }
                const string DEF_OP_FILENAME = "test.pdf";
                if (File.Exists(DEF_OP_FILENAME))
                    File.Delete(DEF_OP_FILENAME);
                using (FileStream fs = new FileStream(DEF_OP_FILENAME, FileMode.OpenOrCreate)) {
                    generatePDFDocument(fs, modelMap);
                }
            }
        }

        #region drag methods
        void lbInstruct_DragEnter(object sender, DragEventArgs e) {
            e.Effect = DragDropEffects.None;
            if (verifyProperDataContent(e, DRAG_TYPE))
                e.Effect = DragDropEffects.Link;
        }

        void lbInstruct_DragDrop(object sender, DragEventArgs e) {
            addDataContent(e, DRAG_TYPE, _instrSheets, lbInstruct);
        }

        void lbOps_DragEnter(object sender, DragEventArgs e) {
            e.Effect = DragDropEffects.None;
            if (verifyProperDataContent(e, DRAG_TYPE))
                e.Effect = DragDropEffects.Link;
        }

        void lbOps_DragDrop(object sender, DragEventArgs e) {
            addDataContent(e, DRAG_TYPE, _opSheets, lbOps);
        }
        #endregion drag methods

        #region main-line
        [STAThread()]
        public static void Main(string[] args) {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new pdf_linksForm());
        }
        #endregion

        #region list-searching methods
        static bool findIndexOf(FullFilePath ffp) {
            return string.Compare(_findFile, ffp.fullPath, true) == 0;
        }

        bool findByRealPath(FullFilePath ffp) {
            return string.Compare(ffp.realPath, _findModel, true) == 0;
        }

        #endregion

        bool verifyProperDataContent(DragEventArgs e, string dragType) {
            string[] files;

            if (e.Data.GetDataPresent(dragType) && (files = e.Data.GetData(dragType) as string[]) != null && files.Length > 0)
                return true;
            return false;
        }

        static void addDataContent(DragEventArgs e, string dragType, List<FullFilePath> alist, ListBox lb) {
            string[] files;
            int nadded = 0;

            if (e.Data.GetDataPresent(DRAG_TYPE) && (files = e.Data.GetData(DRAG_TYPE) as string[]) != null && files.Length > 0) {
                foreach (string aFile in files) {
                    _findFile = aFile;
                    if (!alist.Exists(findIndexOf)) {
                        alist.Add(new FullFilePath(aFile));
                        nadded++;
                    }
                }
            }
            if (nadded > 0) {
                Logger.log("Added " + nadded + " items.");
                lb.DataSource = null;
                lb.DisplayMember = "filename";
                lb.ValueMember = "fullPath";
                lb.DataSource = alist;
            }
        }

        void doNotify(string propName) {
#if !USE_PRIVATE
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propName));
#else
            if (_pceh != null)
                _pceh(this, new PropertyChangedEventArgs(propName));
#endif
        }

        void doNotify(MethodBase mb) {
            string mbname = mb.Name;

            if (mb.Name.StartsWith("set_", StringComparison.InvariantCulture) ||
                mb.Name.StartsWith("get_", StringComparison.InvariantCulture))
                mbname = mb.Name.Substring(4);
            doNotify(mbname);
        }

        void createDocument(string filename) {
            Document doc = new Document(PageSize.LETTER, 50, 50, 50, 50);
            FileStream fs = new FileStream(filename, FileMode.OpenOrCreate);
            PdfWriter writer = PdfWriter.GetInstance(doc, fs);

            try {
                doc.Open();

                doc.Add(new Paragraph("Instruction sheets:"));
                addFromList(doc, _instrSheets);
                doc.Add(new Paragraph("Operation sheets:"));
                addFromList(doc, _opSheets);
                doc.Close();
            } catch (Exception ex) {
                Logger.log(MethodBase.GetCurrentMethod(), ex);
            }
        }

        void addFromList(Document doc, List<FullFilePath> alist) {
            Anchor a;

            foreach (FullFilePath ffp in alist) {
                a = new Anchor(ffp.filename);
                a.Font.Color = BaseColor.BLUE;
                a.Reference = ffp.fullPath;
                doc.Add(a);
                doc.Add(new Rectangle(10, 10));
                doc.Add(new Paragraph());
            }
        }

        static void resetDataSource(ListBox lb, List<FullFilePath> alist) {
            var avar = lb.SelectionMode;

            lb.DataSource = null;
            lb.SelectionMode = SelectionMode.None;
            alist.Clear();
            lb.DataSource = alist;
            lb.SelectionMode = avar;
        }

        void generatePDFDocument(FileStream fs, IDictionary<string, List<FullFilePath>> modelMap) {
            Document doc = new Document(PageSize.LETTER, 50, 50, 50, 50);
            PdfWriter writer = PdfWriter.GetInstance(doc, fs);
            List<string> models = new List<string>();

            try {
                models.AddRange(modelMap.Keys);
                models.Sort();
                doc.AddAuthor("rik-author");
                doc.AddCreationDate();
                doc.AddCreator("rik-creator");
                doc.AddHeader("header-name", "header content");
                doc.AddKeywords("kw1 kw2 kw3 kw4");
                doc.AddLanguage("english");
                doc.AddProducer();
                doc.AddSubject("a subject");
                doc.AddTitle("title");
                doc.Open();
                generateIndex(doc, models);
                generateModelTables(modelMap, doc, models);
                doc.Close();
            } catch (Exception ex) {
                Logger.log(MethodBase.GetCurrentMethod(), ex);
            }
        }

        static void generateModelTables(IDictionary<string, List<FullFilePath>> modelMap, Document doc, List<string> models) {
            PdfPTable table;
            PdfPCell cell;
            Chunk c, c2;

            foreach (string amodel in models) {
                table = new PdfPTable(1);
                table.AddCell(amodel);

                cell = new PdfPCell();
                c = new Chunk("Model " + amodel);
                c2 = c.SetAnchor("page_" + amodel);
                //System.Diagnostics.Trace.WriteLine("anchor=" + c.SetAnchor ();
                cell.AddElement(c);
                table.AddCell(cell);
                generateModelOpLinks(modelMap, doc, table, amodel);
                doc.Add(table);
                doc.Add(new Paragraph());
            }
        }

        static void generateModelOpLinks(IDictionary<string, List<FullFilePath>> modelMap, Document doc, PdfPTable table, string amodel) {
            PdfPCell cell;
            Chunk c;

            foreach (var avar in modelMap[amodel]) {
                cell = new PdfPCell();
                c = new Chunk("Op-" + avar.opNumber);
                c.SetAnchor(avar.fullPath);
                System.Diagnostics.Trace.WriteLine(avar.fullPath);
                cell.AddElement(c);
                table.AddCell(cell);
                doc.Add(new Rectangle(10, 10));
            }
        }

        static void generateIndex(Document doc, List<string> models) {
            Anchor a;
            Paragraph p;
            Font f;

            f = new Font(ITF.FontFamily.COURIER, 10f, iTextSharp.text.Font.NORMAL, BaseColor.BLUE);
            foreach (string amodel in models) {
                a = new Anchor(amodel, f);
                a.Reference = "#page_" + amodel;
                System.Diagnostics.Trace.WriteLine("ref=" + a.Reference);
                p = new Paragraph();
                p.Add(a);
                doc.Add(p);
            }
            doc.NewPage();
        }

        void tsmiFileOpen_Click(object sender, EventArgs e) {
            OpenFileDialog ofd = new OpenFileDialog();
            //string dir;

            ofd.Filter = "PDF|*.pdf";
            ofd.FilterIndex = 0;
            ofd.Multiselect = false;
            if (string.IsNullOrEmpty(prev))
                ofd.InitialDirectory = Directory.GetCurrentDirectory();
            else {
                ofd.InitialDirectory = Path.GetDirectoryName(prev);
                ofd.FileName = Path.GetFileName(prev);
            }
            if (ofd.ShowDialog() == DialogResult.OK) {
                PdfReader reader = new PdfReader(prev = ofd.FileName);
                //PdfReader pdfReader = new PdfReader(fileName);

                //for (int page = 1; page <= reader.NumberOfPages; page++) {
                //    PP.ITextExtractionStrategy strategy = new PP.SimpleTextExtractionStrategy();
                //    string currentText = PP.PdfTextExtractor.GetTextFromPage(reader, page, strategy);

                //    currentText = Encoding.UTF8.GetString(ASCIIEncoding.Convert(Encoding.Default, Encoding.UTF8, Encoding.Default.GetBytes(currentText)));
                //    System.Diagnostics.Trace.WriteLine(currentText);
                //    //text.Append(currentText);
                //}
                //doSomething(reader);
                myproc(reader);
                reader.Close();
            }
        }

        void doSomething(PdfReader reader) {
            //pdfReader.Close();
            string tmp;
            PP.SimpleTextExtractionStrategy blah;
            tester atester = null;
            blah = new PP.SimpleTextExtractionStrategy();
            //Debug.WriteLine("here");
            for (int page = 1; page <= reader.NumberOfPages; page++) {
                //Debug.WriteLine("here");
                var avar = reader.GetLinks(page);
                //Debug.WriteLine("here");
                var v1 = reader.GetNamedDestinationFromNames();
                var v2 = reader.GetNamedDestinationFromStrings();
                var v3 = reader.GetPageContent(page);
                var v4 = reader.GetPageN(page);
                //var v5=reader.get
                //PP.SimpleTextExtractionStrategy blah = new PP.SimpleTextExtractionStrategy();
                tmp = blah.GetResultantText();
                if (atester == null)
                    atester = new tester();
                tmp = PP.PdfTextExtractor.GetTextFromPage(reader, page);
                tmp = PP.PdfTextExtractor.GetTextFromPage(reader, page, blah);
                tmp = PP.PdfTextExtractor.GetTextFromPage(reader, page, atester);
                PP.PdfContentReaderTool.ListContentStreamForPage(reader, page, Console.Out);

                //PdfReaderContentParser
                this.showPage(reader, page);
                //((PP.ITextExtractionStrategy) new tester()).
                Debug.WriteLine("here");
            }
        }

        void showPage(PdfReader reader, int page) {
            PP.PdfReaderContentParser parser;
            MyRenderListener ml = new MyRenderListener();

            parser = new PP.PdfReaderContentParser(reader);
            var avar = parser.ProcessContent<MyRenderListener>(page, ml);
            //var avar2-parser.ProcessContent()
            Trace.WriteLine("here");
        }


        void myproc(PdfReader currentReader) {
            //StringBuilder sb;

            using (PdfDocument document = new PdfDocument()) {
                using (MyDocListener ml = new MyDocListener()) {
                    using (MemoryStream ms = new MemoryStream()) {
                        //using (StreamWriter sw2 = new StreamWriter() {
//                        using (PdfWriter writer = PdfWriter.GetInstance(document, ms, ml)) {
                            using (PdfWriter writer = PdfWriter.GetInstance(document, ms)) {
                                myproc2(currentReader, writer, document);
                        }
                    }
                }
            }
        }

        void myproc2(PdfReader currentReader, PdfWriter writer, PdfDocument document) {

            int firstPage = 1, dPage, newDestPage;
            float ee, ff, a, e, f;

            float W = PageSize.A4.Width / 2;
            float H = PageSize.A4.Height / 2;
            for (int page = 1; page <= currentReader.NumberOfPages; page++) {
                //PdfImportedPage importedPage = writer.GetImportedPage(currentReader, page);
                a = 0.5f;
                e = (page % 2 == 0) ? W : 0;
                f = (page % 4 == 1 || page % 4 == 2) ? H : 0;
                var links = currentReader.GetLinks(page);
                //a     cb.AddTemplate(importedPage, a, 0, 0, a, e, f);
                for (int j = 0; j < links.Count; j++) {
                    PdfAnnotation.PdfImportedLink link = (PdfAnnotation.PdfImportedLink) links[j];
                    if (link.IsInternal()) {
                        dPage = link.GetDestinationPage();
                        newDestPage = (dPage - 1) / 4 + firstPage;
                        ee = (dPage % 2 == 0) ? W : 0;
                        ff = (dPage % 4 == 1 || dPage % 4 == 2) ? H : 0;
                        link.SetDestinationPage(newDestPage);
                        link.TransformDestination(a, 0, 0, a, ee, ff);
                    }
                    link.TransformRect(a, 0, 0, a, e, f);
                    writer.AddAnnotation(link.CreateAnnotation(writer));
                }
                if (page % 4 == 0)
                    document.NewPage();
            }
        }
    }

    class MyDocListener : IDocListener {
        #region fields
          bool disposedValue = false; // To detect redundant calls
          int _pageCount;
          bool _newPage;
          bool _setMarginMirror;
          bool _setMargin;
          bool _setPageSize;
          bool _setMarginMirrorTB; 
        #endregion

        public int PageCount {
            set {
                Logger.log(MethodBase.GetCurrentMethod(),"setting to "+value);
                _pageCount = value;
                //return _pageCount;
            }
        }

        public bool Add(IElement element) {
            Logger.log(MethodBase.GetCurrentMethod());
            throw new NotImplementedException();
        }

        public void Close() {
            Logger.log(MethodBase.GetCurrentMethod());
            //throw new NotImplementedException();
        }

        public bool NewPage() {
            Logger.log(MethodBase.GetCurrentMethod());
            return _newPage;
        }

        public void Open() {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        public void ResetPageCount() {
            Logger.log(MethodBase.GetCurrentMethod());
            _pageCount = 0;
        }

        public bool SetMarginMirroring(bool marginMirroring) {
            Logger.log(MethodBase.GetCurrentMethod());
            return _setMarginMirror;
        }

        public bool SetMarginMirroringTopBottom(bool marginMirroringTopBottom) {
            Logger.log(MethodBase.GetCurrentMethod());
            return _setMarginMirrorTB;
        }

        public bool SetMargins(float marginLeft, float marginRight, float marginTop, float marginBottom) {
            Logger.log(MethodBase.GetCurrentMethod());
            return _setMargin;
        }

        public bool SetPageSize(Rectangle pageSize) {
            Logger.log(MethodBase.GetCurrentMethod());
            return _setPageSize;
        }

        #region IDisposable Support


        protected virtual void Dispose(bool disposing) {
            Logger.log(MethodBase.GetCurrentMethod(),"here-0");
            if (!disposedValue) {
                Logger.log(MethodBase.GetCurrentMethod(), "here-1");
                if (disposing) {
                    Logger.log(MethodBase.GetCurrentMethod(), "here-2");
                    // TODO: dispose managed state (managed objects).
                }

                // TODO: free unmanaged resources (unmanaged objects) and override a finalizer below.
                // TODO: set large fields to null.

                disposedValue = true;
            }
        }

        // TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources.
        // ~MyListener2() {
        //   // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
        //   Dispose(false);
        // }

        // This code added to correctly implement the disposable pattern.
        public void Dispose() {
            Logger.log(MethodBase.GetCurrentMethod(), "here");
            // Do not change this code. Put cleanup code in Dispose(bool disposing) above.
            Dispose(true);
            // TODO: uncomment the following line if the finalizer is overridden above.
            // GC.SuppressFinalize(this);
        }
        #endregion

    }

    class MyRenderListener : PP.IRenderListener {
        void PP.IRenderListener.BeginTextBlock() {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        void PP.IRenderListener.EndTextBlock() {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        void PP.IRenderListener.RenderImage(PP.ImageRenderInfo renderInfo) {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        void PP.IRenderListener.RenderText(PP.TextRenderInfo renderInfo) {
            Logger.log(MethodBase.GetCurrentMethod());
        }
    }

    class tester : PP.ITextExtractionStrategy {
        void PP.IRenderListener.BeginTextBlock() {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        void PP.IRenderListener.EndTextBlock() {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        string PP.ITextExtractionStrategy.GetResultantText() {
            Logger.log(MethodBase.GetCurrentMethod());
            return null;
        }

        void PP.IRenderListener.RenderImage(PP.ImageRenderInfo renderInfo) {
            Logger.log(MethodBase.GetCurrentMethod());
        }

        void PP.IRenderListener.RenderText(PP.TextRenderInfo renderInfo) {
            Logger.log(MethodBase.GetCurrentMethod());
        }
    }
}